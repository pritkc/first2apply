-- Data Protection System for First2Apply
-- This creates triggers and functions to prevent accidental data loss

-- Create a protected data table to track critical records
CREATE TABLE IF NOT EXISTS public.protected_data (
  id bigint generated by default as identity,
  table_name text not null,
  record_id bigint not null,
  operation text not null,
  backup_data jsonb not null,
  created_at timestamp with time zone not null default now(),
  constraint protected_data_pkey primary key (id)
);

-- Enable RLS on protected_data
ALTER TABLE public.protected_data enable row level security;

-- Create policy for protected_data
CREATE POLICY "enable all for service role only" 
ON public.protected_data 
AS permissive 
FOR all 
TO service_role 
USING (true) 
WITH CHECK (true);

-- Function to backup data before deletion
CREATE OR REPLACE FUNCTION backup_before_delete()
RETURNS TRIGGER AS $$
BEGIN
  -- Backup the record before deletion
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  VALUES (
    TG_TABLE_NAME,
    OLD.id,
    'DELETE',
    to_jsonb(OLD)
  );
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Function to backup data before update
CREATE OR REPLACE FUNCTION backup_before_update()
RETURNS TRIGGER AS $$
BEGIN
  -- Backup the record before update
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  VALUES (
    TG_TABLE_NAME,
    OLD.id,
    'UPDATE',
    jsonb_build_object(
      'old_data', to_jsonb(OLD),
      'new_data', to_jsonb(NEW)
    )
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for critical tables
-- Sites table protection
DROP TRIGGER IF EXISTS protect_sites_delete ON public.sites;
CREATE TRIGGER protect_sites_delete
  BEFORE DELETE ON public.sites
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_delete();

DROP TRIGGER IF EXISTS protect_sites_update ON public.sites;
CREATE TRIGGER protect_sites_update
  BEFORE UPDATE ON public.sites
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_update();

-- Jobs table protection
DROP TRIGGER IF EXISTS protect_jobs_delete ON public.jobs;
CREATE TRIGGER protect_jobs_delete
  BEFORE DELETE ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_delete();

DROP TRIGGER IF EXISTS protect_jobs_update ON public.jobs;
CREATE TRIGGER protect_jobs_update
  BEFORE UPDATE ON public.jobs
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_update();

-- Advanced matching table protection
DROP TRIGGER IF EXISTS protect_advanced_matching_delete ON public.advanced_matching;
CREATE TRIGGER protect_advanced_matching_delete
  BEFORE DELETE ON public.advanced_matching
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_delete();

DROP TRIGGER IF EXISTS protect_advanced_matching_update ON public.advanced_matching;
CREATE TRIGGER protect_advanced_matching_update
  BEFORE UPDATE ON public.advanced_matching
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_update();

-- Links table protection
DROP TRIGGER IF EXISTS protect_links_delete ON public.links;
CREATE TRIGGER protect_links_delete
  BEFORE DELETE ON public.links
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_delete();

DROP TRIGGER IF EXISTS protect_links_update ON public.links;
CREATE TRIGGER protect_links_update
  BEFORE UPDATE ON public.links
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_update();

-- Notes table protection
DROP TRIGGER IF EXISTS protect_notes_delete ON public.notes;
CREATE TRIGGER protect_notes_delete
  BEFORE UPDATE ON public.notes
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_update();

DROP TRIGGER IF EXISTS protect_notes_update ON public.notes;
CREATE TRIGGER protect_notes_update
  BEFORE UPDATE ON public.notes
  FOR EACH ROW
  EXECUTE FUNCTION backup_before_update();

-- Function to restore data from protection table
CREATE OR REPLACE FUNCTION restore_protected_data(
  target_table text,
  target_id bigint,
  operation text DEFAULT 'DELETE'
)
RETURNS text AS $$
DECLARE
  backup_record record;
  restore_sql text;
BEGIN
  -- Find the backup record
  SELECT * INTO backup_record
  FROM public.protected_data
  WHERE table_name = target_table
    AND record_id = target_id
    AND operation = operation
  ORDER BY created_at DESC
  LIMIT 1;
  
  IF NOT FOUND THEN
    RETURN 'No backup found for table ' || target_table || ' record ' || target_id;
  END IF;
  
  -- Generate restore SQL based on operation
  IF operation = 'DELETE' THEN
    restore_sql := 'INSERT INTO public.' || target_table || ' SELECT * FROM jsonb_populate_record(null::public.' || target_table || ', $1)';
    EXECUTE restore_sql USING backup_record.backup_data;
    RETURN 'Record restored successfully';
  ELSIF operation = 'UPDATE' THEN
    restore_sql := 'UPDATE public.' || target_table || ' SET ' || 
                   (SELECT string_agg(key || ' = $1->>' || quote_literal(key), ', ')
                    FROM jsonb_object_keys(backup_record.backup_data->'old_data') AS key) ||
                   ' WHERE id = $2';
    EXECUTE restore_sql USING backup_record.backup_data->'old_data', target_id;
    RETURN 'Record updated from backup successfully';
  ELSE
    RETURN 'Unsupported operation: ' || operation;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to list all protected data
CREATE OR REPLACE FUNCTION list_protected_data()
RETURNS TABLE (
  table_name text,
  record_id bigint,
  operation text,
  created_at timestamp with time zone,
  backup_size bigint
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pd.table_name,
    pd.record_id,
    pd.operation,
    pd.created_at,
    jsonb_array_length(pd.backup_data) as backup_size
  FROM public.protected_data pd
  ORDER BY pd.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create a view for easy access to protected data
CREATE OR REPLACE VIEW public.protected_data_summary AS
SELECT 
  table_name,
  operation,
  COUNT(*) as record_count,
  MIN(created_at) as earliest_backup,
  MAX(created_at) as latest_backup
FROM public.protected_data
GROUP BY table_name, operation
ORDER BY table_name, operation;

-- Grant permissions
GRANT SELECT ON public.protected_data_summary TO authenticated;
GRANT EXECUTE ON FUNCTION restore_protected_data(text, bigint, text) TO authenticated;
GRANT EXECUTE ON FUNCTION list_protected_data() TO authenticated;

-- Insert initial protection record for current data
INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
SELECT 
  'sites' as table_name,
  id as record_id,
  'PROTECT' as operation,
  to_jsonb(s.*) as backup_data
FROM public.sites s
ON CONFLICT DO NOTHING;

INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
SELECT 
  'jobs' as table_name,
  id as record_id,
  'PROTECT' as operation,
  to_jsonb(j.*) as backup_data
FROM public.jobs j
ON CONFLICT DO NOTHING;

INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
SELECT 
  'advanced_matching' as table_name,
  id as record_id,
  'PROTECT' as operation,
  to_jsonb(am.*) as backup_data
FROM public.advanced_matching am
ON CONFLICT DO NOTHING;

INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
SELECT 
  'links' as table_name,
  id as record_id,
  'PROTECT' as operation,
  to_jsonb(l.*) as backup_data
FROM public.links l
ON CONFLICT DO NOTHING;

INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
SELECT 
  'notes' as table_name,
  id as record_id,
  'PROTECT' as operation,
  to_jsonb(n.*) as backup_data
FROM public.notes n
ON CONFLICT DO NOTHING;

-- Create a function to force backup of all current data
CREATE OR REPLACE FUNCTION force_full_backup()
RETURNS text AS $$
DECLARE
  backup_count integer := 0;
BEGIN
  -- Backup all current data
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  SELECT 
    'sites' as table_name,
    id as record_id,
    'FORCE_BACKUP' as operation,
    to_jsonb(s.*) as backup_data
  FROM public.sites s
  ON CONFLICT DO NOTHING;
  
  GET DIAGNOSTICS backup_count = ROW_COUNT;
  
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  SELECT 
    'jobs' as table_name,
    id as record_id,
    'FORCE_BACKUP' as operation,
    to_jsonb(j.*) as backup_data
  FROM public.jobs j
  ON CONFLICT DO NOTHING;
  
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  SELECT 
    'advanced_matching' as table_name,
    id as record_id,
    'FORCE_BACKUP' as operation,
    to_jsonb(am.*) as backup_data
  FROM public.advanced_matching am
  ON CONFLICT DO NOTHING;
  
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  SELECT 
    'links' as table_name,
    id as record_id,
    'FORCE_BACKUP' as operation,
    to_jsonb(l.*) as backup_data
  FROM public.links l
  ON CONFLICT DO NOTHING;
  
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  SELECT 
    'notes' as table_name,
    id as record_id,
    'FORCE_BACKUP' as operation,
    to_jsonb(n.*) as backup_data
  FROM public.notes n
  ON CONFLICT DO NOTHING;
  
  RETURN 'Full backup completed. Protected ' || backup_count || ' records.';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION force_full_backup() TO authenticated;

-- Create a function to check data protection status
CREATE OR REPLACE FUNCTION check_data_protection_status()
RETURNS TABLE (
  table_name text,
  current_records bigint,
  protected_records bigint,
  last_backup timestamp with time zone,
  protection_status text
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.tbl_name,
    t.current_records,
    COALESCE(p.protected_records, 0) as protected_records,
    p.last_backup,
    CASE 
      WHEN p.protected_records >= t.current_records THEN '✅ PROTECTED'
      WHEN p.protected_records > 0 THEN '⚠️  PARTIALLY PROTECTED'
      ELSE '❌ NOT PROTECTED'
    END as protection_status
  FROM (
    SELECT 'sites' as tbl_name, COUNT(*) as current_records FROM public.sites
    UNION ALL
    SELECT 'jobs' as tbl_name, COUNT(*) as current_records FROM public.jobs
    UNION ALL
    SELECT 'advanced_matching' as tbl_name, COUNT(*) as current_records FROM public.advanced_matching
    UNION ALL
    SELECT 'links' as tbl_name, COUNT(*) as current_records FROM public.links
    UNION ALL
    SELECT 'notes' as tbl_name, COUNT(*) as current_records FROM public.notes
  ) t
  LEFT JOIN (
    SELECT 
      table_name,
      COUNT(*) as protected_records,
      MAX(created_at) as last_backup
    FROM public.protected_data
    GROUP BY table_name
  ) p ON t.tbl_name = p.table_name
  ORDER BY t.tbl_name;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION check_data_protection_status() TO authenticated;

-- Execute initial full backup
SELECT force_full_backup();

-- Display protection status
SELECT * FROM check_data_protection_status();
