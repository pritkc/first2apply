-- Enhanced User Protection Script
-- This script makes user deletion absolutely impossible

-- 1. Create a super-protected user profiles table
CREATE TABLE IF NOT EXISTS public.super_protected_profiles (
  id bigint GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid NOT NULL UNIQUE,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  protected_until timestamp with time zone NOT NULL DEFAULT (now() + interval '100 years'),
  protection_level text NOT NULL DEFAULT 'MAXIMUM',
  backup_count integer NOT NULL DEFAULT 0,
  last_backup_at timestamp with time zone,
  CONSTRAINT super_protected_profiles_pkey PRIMARY KEY (id),
  CONSTRAINT super_protected_profiles_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES auth.users (id) ON DELETE RESTRICT
);

-- 2. Create a function that prevents user deletion
CREATE OR REPLACE FUNCTION public.prevent_user_deletion()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  -- Check if user has any data in the system
  IF EXISTS (
    SELECT 1 FROM public.profiles WHERE user_id = OLD.id
    UNION ALL
    SELECT 1 FROM public.jobs WHERE user_id = OLD.id
    UNION ALL
    SELECT 1 FROM public.links WHERE user_id = OLD.id
    UNION ALL
    SELECT 1 FROM public.notes WHERE user_id = OLD.id
    UNION ALL
    SELECT 1 FROM public.reviews WHERE user_id = OLD.id
    UNION ALL
    SELECT 1 FROM public.advanced_matching WHERE user_id = OLD.id
    UNION ALL
    SELECT 1 FROM public.html_dumps WHERE user_id = OLD.id
  ) THEN
    RAISE EXCEPTION 'USER_DELETION_FORBIDDEN: Cannot delete user % - user has data in the system. Use data anonymization instead.', OLD.id;
  END IF;
  
  RETURN OLD;
END;
$$;

-- 3. Create trigger to prevent user deletion
DROP TRIGGER IF EXISTS prevent_user_deletion_trigger ON auth.users;
CREATE TRIGGER prevent_user_deletion_trigger
  BEFORE DELETE ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.prevent_user_deletion();

-- 4. Create a function to check user protection status
CREATE OR REPLACE FUNCTION public.check_user_protection_status(target_user_id uuid)
RETURNS TABLE(
  user_id uuid,
  has_profile boolean,
  has_jobs boolean,
  has_links boolean,
  has_notes boolean,
  has_reviews boolean,
  has_advanced_matching boolean,
  has_html_dumps boolean,
  total_records bigint,
  protection_level text,
  can_be_deleted boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    target_user_id,
    EXISTS(SELECT 1 FROM public.profiles WHERE user_id = target_user_id),
    EXISTS(SELECT 1 FROM public.jobs WHERE user_id = target_user_id),
    EXISTS(SELECT 1 FROM public.links WHERE user_id = target_user_id),
    EXISTS(SELECT 1 FROM public.notes WHERE user_id = target_user_id),
    EXISTS(SELECT 1 FROM public.reviews WHERE user_id = target_user_id),
    EXISTS(SELECT 1 FROM public.advanced_matching WHERE user_id = target_user_id),
    EXISTS(SELECT 1 FROM public.html_dumps WHERE user_id = target_user_id),
    (
      (SELECT COUNT(*) FROM public.jobs WHERE user_id = target_user_id) +
      (SELECT COUNT(*) FROM public.links WHERE user_id = target_user_id) +
      (SELECT COUNT(*) FROM public.notes WHERE user_id = target_user_id) +
      (SELECT COUNT(*) FROM public.reviews WHERE user_id = target_user_id) +
      (SELECT COUNT(*) FROM public.advanced_matching WHERE user_id = target_user_id) +
      (SELECT COUNT(*) FROM public.html_dumps WHERE user_id = target_user_id)
    ) as total_records,
    'MAXIMUM'::text as protection_level,
    false as can_be_deleted;
END;
$$;

-- 5. Create a function for safe user data anonymization (instead of deletion)
CREATE OR REPLACE FUNCTION public.anonymize_user_data(target_user_id uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  anonymized_count integer := 0;
  backup_id bigint;
BEGIN
  -- First, create a comprehensive backup
  INSERT INTO public.protected_data (table_name, record_id, operation, backup_data)
  SELECT 
    'user_anonymization' as table_name,
    target_user_id::text::bigint as record_id,
    'ANONYMIZATION_BACKUP' as operation,
    jsonb_build_object(
      'user_id', target_user_id,
      'profiles', (SELECT to_jsonb(p.*) FROM public.profiles p WHERE p.user_id = target_user_id),
      'jobs', (SELECT jsonb_agg(to_jsonb(j.*)) FROM public.jobs j WHERE j.user_id = target_user_id),
      'links', (SELECT jsonb_agg(to_jsonb(l.*)) FROM public.links l WHERE l.user_id = target_user_id),
      'notes', (SELECT jsonb_agg(to_jsonb(n.*)) FROM public.notes n WHERE n.user_id = target_user_id),
      'reviews', (SELECT to_jsonb(r.*) FROM public.reviews r WHERE r.user_id = target_user_id),
      'advanced_matching', (SELECT to_jsonb(am.*) FROM public.advanced_matching am WHERE am.user_id = target_user_id),
      'html_dumps', (SELECT jsonb_agg(to_jsonb(hd.*)) FROM public.html_dumps hd WHERE hd.user_id = target_user_id)
    ) as backup_data
  RETURNING id INTO backup_id;
  
  -- Anonymize jobs (mark as deleted instead of actually deleting)
  UPDATE public.jobs 
  SET 
    title = '[ANONYMIZED]',
    "companyName" = '[ANONYMIZED]',
    description = '[ANONYMIZED]',
    status = 'deleted'::public."Job Status",
    updated_at = now()
  WHERE user_id = target_user_id;
  
  GET DIAGNOSTICS anonymized_count = ROW_COUNT;
  
  -- Anonymize other data similarly
  UPDATE public.links 
  SET 
    title = '[ANONYMIZED]',
    url = '[ANONYMIZED]'
  WHERE user_id = target_user_id;
  
  UPDATE public.notes 
  SET 
    text = '[ANONYMIZED]'
  WHERE user_id = target_user_id;
  
  UPDATE public.reviews 
  SET 
    title = '[ANONYMIZED]',
    description = '[ANONYMIZED]'
  WHERE user_id = target_user_id;
  
  -- Delete advanced matching and html dumps (these don't contain personal info)
  DELETE FROM public.advanced_matching WHERE user_id = target_user_id;
  DELETE FROM public.html_dumps WHERE user_id = target_user_id;
  
  -- Update profile to mark as anonymized
  UPDATE public.profiles 
  SET 
    subscription_tier = 'anonymized',
    is_trial = false
  WHERE user_id = target_user_id;
  
  RETURN 'User data anonymized successfully. Backup ID: ' || backup_id || '. Anonymized ' || anonymized_count || ' job records.';
END;
$$;

-- 6. Create a view to monitor user protection status
CREATE OR REPLACE VIEW public.user_protection_status AS
SELECT 
  u.id as user_id,
  u.email,
  u.created_at as user_created_at,
  p.subscription_tier,
  p.is_trial,
  (
    SELECT COUNT(*) FROM public.jobs WHERE user_id = u.id
  ) as job_count,
  (
    SELECT COUNT(*) FROM public.links WHERE user_id = u.id
  ) as link_count,
  (
    SELECT COUNT(*) FROM public.notes WHERE user_id = u.id
  ) as note_count,
  (
    SELECT COUNT(*) FROM public.reviews WHERE user_id = u.id
  ) as review_count,
  (
    SELECT COUNT(*) FROM public.advanced_matching WHERE user_id = u.id
  ) as advanced_matching_count,
  (
    SELECT COUNT(*) FROM public.html_dumps WHERE user_id = u.id
  ) as html_dump_count,
  CASE 
    WHEN EXISTS(SELECT 1 FROM public.jobs WHERE user_id = u.id) THEN 'PROTECTED'
    WHEN EXISTS(SELECT 1 FROM public.links WHERE user_id = u.id) THEN 'PROTECTED'
    WHEN EXISTS(SELECT 1 FROM public.notes WHERE user_id = u.id) THEN 'PROTECTED'
    WHEN EXISTS(SELECT 1 FROM public.reviews WHERE user_id = u.id) THEN 'PROTECTED'
    WHEN EXISTS(SELECT 1 FROM public.advanced_matching WHERE user_id = u.id) THEN 'PROTECTED'
    WHEN EXISTS(SELECT 1 FROM public.html_dumps WHERE user_id = u.id) THEN 'PROTECTED'
    ELSE 'UNPROTECTED'
  END as protection_status
FROM auth.users u
LEFT JOIN public.profiles p ON u.id = p.user_id
ORDER BY u.created_at DESC;

-- 7. Grant necessary permissions
GRANT SELECT ON public.user_protection_status TO authenticated;
GRANT EXECUTE ON FUNCTION public.check_user_protection_status(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.anonymize_user_data(uuid) TO service_role;

-- 8. Create an emergency protection function
CREATE OR REPLACE FUNCTION public.emergency_protect_all_users()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  protected_count integer := 0;
BEGIN
  -- Create super protection records for all users
  INSERT INTO public.super_protected_profiles (user_id, protection_level)
  SELECT 
    u.id,
    'EMERGENCY_MAXIMUM'
  FROM auth.users u
  WHERE NOT EXISTS (
    SELECT 1 FROM public.super_protected_profiles spp 
    WHERE spp.user_id = u.id
  )
  ON CONFLICT (user_id) DO UPDATE SET
    protection_level = 'EMERGENCY_MAXIMUM',
    protected_until = now() + interval '100 years';
  
  GET DIAGNOSTICS protected_count = ROW_COUNT;
  
  -- Force backup all user data
  PERFORM public.force_full_backup();
  
  RETURN 'Emergency protection activated for ' || protected_count || ' users. All data backed up.';
END;
$$;

-- 9. Create a function to check if user deletion is safe
CREATE OR REPLACE FUNCTION public.is_user_deletion_safe(target_user_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Check if user has any data
  IF EXISTS (
    SELECT 1 FROM public.jobs WHERE user_id = target_user_id
    UNION ALL
    SELECT 1 FROM public.links WHERE user_id = target_user_id
    UNION ALL
    SELECT 1 FROM public.notes WHERE user_id = target_user_id
    UNION ALL
    SELECT 1 FROM public.reviews WHERE user_id = target_user_id
    UNION ALL
    SELECT 1 FROM public.advanced_matching WHERE user_id = target_user_id
    UNION ALL
    SELECT 1 FROM public.html_dumps WHERE user_id = target_user_id
  ) THEN
    RETURN false;
  END IF;
  
  RETURN true;
END;
$$;

COMMENT ON FUNCTION public.prevent_user_deletion() IS 'Prevents deletion of users who have data in the system';
COMMENT ON FUNCTION public.anonymize_user_data(uuid) IS 'Safely anonymizes user data instead of deleting it';
COMMENT ON FUNCTION public.emergency_protect_all_users() IS 'Emergency function to protect all users and backup all data';
COMMENT ON FUNCTION public.is_user_deletion_safe(uuid) IS 'Checks if a user can be safely deleted';
COMMENT ON VIEW public.user_protection_status IS 'Shows protection status for all users';
