create table
public.sites (
  id bigint generated by default as identity,
  name text not null,
  urls text[] not null,
  created_at timestamp with time zone not null default now(),
  "queryParamsToRemove" text[] null,
  logo_url text not null,
  blacklisted_paths text[] not null default '{/}'::text[],
  provider text not null,
  deprecated boolean not null default false,
  incognito_support boolean not null default false,
  constraint sites_pkey primary key (id)
) tablespace pg_default;

create table
public.links (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  user_id uuid not null default auth.uid (),
  url text not null,
  title text not null,
  site_id bigint not null,
  scrape_failure_count integer not null default 0,
  last_scraped_at timestamp with time zone not null default (now() at time zone 'utc'::text),
  scrape_failure_email_sent boolean not null default false,
  constraint links_pkey primary key (id),
  constraint links_site_id_fkey foreign key (site_id) references sites (id) on update restrict on delete restrict,
  constraint links_user_id_fkey foreign key (user_id) references auth.users (id) on delete restrict
) tablespace pg_default;

-- create Job Status enum with values new, applied, archived, deleted
create type public."Job Status" as enum ('new', 'applied', 'archived', 'deleted', 'processing', 'excluded_by_advanced_matching');

-- ensure 'deleted' exists in case the enum was created previously without it
do $$
begin
  if not exists (
    select 1
    from pg_type t
    join pg_enum e on t.oid = e.enumtypid
    join pg_namespace n on n.oid = t.typnamespace
    where n.nspname = 'public'
      and t.typname = 'Job Status'
      and e.enumlabel = 'deleted'
  ) then
    alter type public."Job Status" add value 'deleted';
  end if;
end $$;
create table
public.jobs (
  id bigint generated by default as identity,
  user_id uuid not null default auth.uid (),
  "externalId" text not null,
  "externalUrl" text not null,
  "siteId" bigint not null,
  title text not null,
  "companyName" text not null,
  "companyLogo" text null,
  location text null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  salary text null,
  tags text[] null,
  "jobType" text null,
  status public."Job Status" not null default 'new'::"Job Status",
  description text null,
  labels text[] not null default '{}'::text[],
  link_id bigint null,
  exclude_reason text null,
  constraint jobs_pkey primary key (id),
  constraint jobs_user_id_externalid_key unique (user_id, "externalId"),
  constraint jobs_user_id_fkey foreign key (user_id) references auth.users (id) on delete restrict,
  constraint jobs_siteid_fkey foreign key ("siteId") references sites (id) on update restrict on delete restrict,
  constraint public_jobs_link_id_fkey foreign key (link_id) references links (id) on update cascade on delete set null
) tablespace pg_default;
create index jobs_user_id_updated_at_id_status_idx on public.jobs (user_id, updated_at desc, id desc, status);

create table
public.reviews (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  user_id uuid not null default auth.uid (),
  title text not null,
  description text null,
  rating integer not null,
  constraint reviews_pkey primary key (id),
  constraint reviews_user_id_fkey foreign key (user_id) references auth.users (id) on delete restrict,
  constraint unique_user_review unique (user_id) -- This enforces one review per user for the app
) tablespace pg_default;

create table
public.html_dumps (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  user_id uuid not null default auth.uid (),
  url text not null,
  html text not null,
  constraint html_dumps_pkey primary key (id)
) tablespace pg_default;

create table
public.notes (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  user_id uuid not null default auth.uid (),
  text text not null,
  files text[] not null default '{}'::text[],
  job_id bigint not null,
  constraint notes_pkey primary key (id),
  constraint notes_user_id_fkey foreign key (user_id) references auth.users (id) on update cascade on delete cascade,
  constraint notes_job_id_fkey foreign key (job_id) references jobs (id) on update cascade on delete cascade
) tablespace pg_default;
alter table public.notes enable row level security;
create policy "enable all for users based on user_id" 
on public.notes 
as permissive 
for all 
to authenticated 
using (auth.uid() = user_id) 
with check (auth.uid() = user_id);

alter table public.sites enable row level security;
alter table public.jobs enable row level security;
alter table public.links enable row level security;
alter table public.reviews enable row level security;
alter table public.html_dumps enable row level security;
alter table public.notes enable row level security;

-- row level security
create policy "enable select for authenticated users only" 
on public.sites 
as permissive 
for select 
to authenticated 
using (true);

create policy "enable all for users based on user_id" 
on public.links 
as permissive 
for all 
to authenticated 
using (auth.uid() = user_id) 
with check (auth.uid() = user_id);

create policy "enable all for users based on user_id" 
on public.jobs 
as permissive 
for all 
to authenticated 
using (auth.uid() = user_id) 
with check (auth.uid() = user_id);

create policy "enable insert reviews for authenticated users only" 
on public.reviews 
as permissive 
for insert 
to authenticated 
with check (auth.uid() = user_id);

create policy "enable update reviews for authenticated users only"
on public.reviews
as permissive
for update
to authenticated
using (auth.uid() = user_id);

create policy "enable select reviews for authenticated users only" 
on public.reviews 
as permissive 
for select 
to authenticated 
using (auth.uid() = user_id);

create policy "enable all for users based on user_id" 
on public.html_dumps 
as permissive 
for all 
to authenticated 
using (auth.uid() = user_id) 
with check (auth.uid() = user_id);

create table
public.profiles (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  user_id uuid not null default auth.uid (),
  stripe_customer_id text null,
  stripe_subscription_id text null,
  subscription_end_date timestamp without time zone not null default (now() + '7 days'::interval),
  subscription_tier text not null default 'basic'::text,
  is_trial boolean not null default true,
  constraint profiles_pkey primary key (id),
  constraint profiles_user_id_key unique (user_id),
  constraint profiles_user_id_fkey foreign key (user_id) references auth.users (id) on delete restrict
) tablespace pg_default;

alter table public.profiles enable row level security;
create policy "enable select profiles for authenticated users only" 
on public.profiles 
as permissive 
for select 
to authenticated 
using (auth.uid() = user_id);

-- create custom DB functions
create or replace function list_jobs(
    jobs_status "Job Status", 
    jobs_after text, 
    jobs_page_size integer, 
    jobs_search text default null,
    jobs_site_ids integer[] default null,
    jobs_link_ids integer[] default null,
    jobs_labels text[] default null,
    jobs_favorites_only boolean default null,
    jobs_hide_reposts boolean default null,
    jobs_show_reposts_only boolean default null
)
returns setof jobs as $$
declare
  after_id integer;
  after_updated_at timestamp;
begin
  if jobs_after is not null then
    after_id := split_part(jobs_after, '!', 1)::integer;
    after_updated_at := split_part(jobs_after, '!', 2)::timestamp;
  end if;

  return query
  select *
  from jobs
  where status = jobs_status
    and (jobs_after is null or (updated_at, id) < (after_updated_at, after_id))
    and (array_length(jobs_site_ids, 1) is null or "siteId" = any(jobs_site_ids))
    and (array_length(jobs_link_ids, 1) is null or link_id = any(jobs_link_ids))
    and (array_length(jobs_labels, 1) is null or labels && jobs_labels)
    and (
      coalesce(jobs_favorites_only, false) = false
      or exists (
        select 1
        from public.advanced_matching am, unnest(am.favorite_companies) fc
        where am.user_id = auth.uid()
          and lower(fc) = lower(jobs."companyName")
      )
    )
    and (jobs_search is null or job_search_vector @@ plainto_tsquery('english', jobs_search))
  order by updated_at desc, id desc
  limit jobs_page_size;
end; $$
language plpgsql;

create or replace function get_user_id_by_email(email text)
returns table (id uuid)
security definer
as $$
begin
  return query select au.id from auth.users au where au.email = $1;
end;
$$ language plpgsql;

-- trigger used to automatically create public.profiles for new users
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (user_id)
  values (new.id);
  return new;
end;
$$;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- migration script
-- insert into public.profiles (user_id)
-- select id from auth.users
-- where id not in (select user_id from public.profiles);

-- Stripe DB wrappers (commented out for local development)
-- create extension if not exists wrappers with schema extensions;
-- create foreign data wrapper stripe_wrapper
--   handler stripe_fdw_handler
--   validator stripe_fdw_validator;

-- insert into vault.secrets (name, secret)
-- values (
--   'stripe_secret_key',
--   'YOUR_SECRET'
-- )
-- returning key_id;

-- create server stripe_server
--   foreign data wrapper stripe_wrapper
--   options (
--     api_key_id 'stripe_secret_key',
--     api_url 'https://api.stripe.com/v1/'  -- Stripe API base URL, optional. Default is 'https://api.stripe.com/v1/'
--   );

-- create schema stripe;
-- create foreign table stripe.customers (
--   id text,
--   email text,
--   name text,
--   description text,
--   created timestamp,
--   attrs jsonb
-- )
--   server stripe_server
--   options (
--     object 'customers',
--     rowid_column 'id'
--   );
  
-- create foreign table stripe.subscriptions (
--   id text,
--   customer text,
--   currency text,
--   current_period_start timestamp,
--   current_period_end timestamp,
--   attrs jsonb
-- )
--   server stripe_server
--   options (
--     object 'subscriptions',
--     rowid_column 'id'
--   );

-- advanced matching
create table
public.advanced_matching (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  user_id uuid not null default auth.uid (),
  blacklisted_companies text[] not null default '{}'::text[],
  favorite_companies text[] not null default '{}'::text[],
  chatgpt_prompt text not null default ''::text,
  ai_api_cost double precision not null default '0'::double precision,
  ai_api_input_tokens_used double precision not null default '0'::double precision,
  ai_api_output_tokens_used double precision not null default '0'::double precision,
  constraint advanced_matching_pkey primary key (id),
  constraint advanced_matching_user_id_key unique (user_id),
  constraint advanced_matching_user_id_fkey foreign key (user_id) references auth.users (id) on update restrict on delete restrict
) tablespace pg_default;
alter table public.advanced_matching enable row level security;
create policy "enable all for users based on user_id" 
on public.advanced_matching 
as permissive 
for all 
to authenticated 
using (auth.uid() = user_id) 
with check (auth.uid() = user_id);

create or replace function count_chatgpt_usage(
  for_user_id uuid, 
  cost_increment numeric, 
  input_tokens_increment integer, 
  output_tokens_increment integer
) 
returns void 
language plpgsql 
as $$
begin
  update public.advanced_matching
  set 
    ai_api_cost = ai_api_cost + cost_increment, 
    ai_api_input_tokens_used = ai_api_input_tokens_used + input_tokens_increment, 
    ai_api_output_tokens_used = ai_api_output_tokens_used + output_tokens_increment
  where user_id = for_user_id;
end;
$$;

-- create search vector for jobs
alter table public.jobs
add column job_search_vector tsvector;

create or replace function update_job_search_vector()
returns trigger as $$
begin
  -- Update the job_search_vector column with weighted tsvector values
  new.job_search_vector := 
    setweight(to_tsvector('english', coalesce(new.title, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(new."companyName", '')), 'B');
  return new;
end;
$$ language plpgsql;

create trigger trigger_update_job_search_vector
before insert or update of title, "companyName" on jobs
for each row
execute function update_job_search_vector();

-- run this one time to update all existing rows
DO $$
DECLARE
  batch_size INT := 10000;
  min_id INT;
  max_id INT;
BEGIN
  -- Find the range of IDs in the table
  SELECT MIN(id), MAX(id) INTO min_id, max_id FROM public.jobs;

  -- Process in batches
  WHILE min_id <= max_id LOOP
    UPDATE public.jobs
    SET job_search_vector = 
      setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
      setweight(to_tsvector('english', coalesce("companyName", '')), 'B')
    WHERE id >= min_id AND id < min_id + batch_size;

    -- Move to the next batch
    min_id := min_id + batch_size;

    -- Optionally, log progress
    RAISE NOTICE 'Processed up to ID: %', min_id;
  END LOOP;
END $$;

create or replace function count_jobs(
    jobs_status "Job Status" default null, 
    jobs_search text default null,
    jobs_site_ids integer[] default null,
    jobs_link_ids integer[] default null,
    jobs_labels text[] default null,
    jobs_favorites_only boolean default null,
    jobs_hide_reposts boolean default null,
    jobs_show_reposts_only boolean default null
)
returns table(status "Job Status", job_count bigint) as $$
begin
  return query
  select j.status, count(*) as job_count
  from jobs j
  where (jobs_status is null or j.status = jobs_status)
    and (array_length(jobs_site_ids, 1) is null or j."siteId" = any(jobs_site_ids))
    and (array_length(jobs_link_ids, 1) is null or j.link_id = any(jobs_link_ids))
    and (array_length(jobs_labels, 1) is null or labels && jobs_labels)
    and (
      coalesce(jobs_favorites_only, false) = false
      or exists (
        select 1
        from public.advanced_matching am, unnest(am.favorite_companies) fc
        where am.user_id = auth.uid()
          and lower(fc) = lower(j."companyName")
      )
    )
    and (jobs_search is null or j.job_search_vector @@ plainto_tsquery('english', jobs_search))
  group by j.status
  order by j.status;
end; $$
language plpgsql;

