import { createClient } from '@supabase/supabase-js';
import { BrowserWindow, Notification, app, dialog, nativeTheme, safeStorage, shell } from 'electron';
import Storage from 'electron-store';
import fs from 'fs';
import path from 'path';

import { DbSchema } from '../../supabase/functions/_shared/types';
import { ENV } from './env';
import { getExceptionMessage } from './lib/error';
import { AmplitudeAnalyticsClient } from './server/amplitude';
import { F2aAutoUpdater } from './server/autoUpdater';
import { promiseAllSequence } from './server/helpers';
import { HtmlDownloader } from './server/htmlDownloader';
import { JobBoardModal } from './server/jobBoardModal';
import { JobScanner } from './server/jobScanner';
import { logger, LogSection } from './server/logger';
import { initRendererIpcApi } from './server/rendererIpcApi';
import { F2aSupabaseApi } from './server/supabaseApi';
import { TrayMenu } from './server/trayMenu';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const APP_PROTOCOL = 'first2apply';
let appIsRunning = false;
const storage = new Storage<{
  width: number;
  height: number;
}>({ defaults: { width: 1024, height: 800 } });

// register the custom protocol
if (process.defaultApp) {
  if (process.argv.length >= 2) {
    app.setAsDefaultProtocolClient(APP_PROTOCOL, process.execPath, [path.resolve(process.argv[1])]);
  }
} else {
  app.setAsDefaultProtocolClient(APP_PROTOCOL);
}

let mainWindow: BrowserWindow | null = null;
let trayIconNotificationShown = false;
const createMainWindow = () => {
  // Create the browser window.
  if (mainWindow) return;
  const theme = nativeTheme.shouldUseDarkColors ? 'dark' : 'light';
  mainWindow = new BrowserWindow({
    width: storage.get('width'),
    height: storage.get('height'),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      additionalArguments: [theme],
      partition: `persist:scraper`,
    },
    autoHideMenuBar: false,
    show: true,
    skipTaskbar: false,
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  if (ENV.nodeEnv === 'development') {
    // Open the DevTools.
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on('close', (event) => {
    if (appIsRunning) {
      event.preventDefault();
      onHideToSystemTray();
    }
  });

  // open all external links in the default browser
  mainWindow.webContents.on('will-navigate', (event, url) => {
    if (url.startsWith('http') && !url.includes('main_window')) {
      event.preventDefault();
      shell.openExternal(url);
    }
  });

  return mainWindow;
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  bootstrap();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  app.quit();
});

// do not close all windows when the app is quit on macOS, instead hide the main window
app.on('before-quit', (event) => {
  if (appIsRunning) {
    event.preventDefault();
    onHideToSystemTray();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  onActivate();
});

function onActivate() {
  if (!mainWindow?.isVisible()) {
    // show the dock icon on macOS and show the taskbar icon on Windows
    if (process.platform === 'darwin') {
      app.dock.show();
    } else if (process.platform === 'win32') {
      mainWindow?.setSkipTaskbar(false);
    }

    mainWindow?.show();
  }

  if (mainWindow?.isMinimized()) {
    mainWindow?.restore();
  }

  mainWindow?.focus();
}
function onHideToSystemTray() {
  mainWindow?.hide();

  // hide the dock icon on macOS and hide the taskbar icon on Windows
  if (process.platform === 'darwin') {
    app.dock.hide();
  } else if (process.platform === 'win32') {
    mainWindow?.setSkipTaskbar(true);
  }

  // dirty hack to fix navigating to the right tab in home page
  // when closing we navigate to help page
  mainWindow?.webContents.send('navigate', { path: '/help' });

  // send notification to inform the user that the app is still running
  if (!trayIconNotificationShown) {
    trayIconNotificationShown = true;
    const notification = new Notification({
      title: 'See you soon!',
      body: 'First 2 Apply is still checking for new jobs in the background. Click the paper airplane icon in your system tray to open the app.',
    });
    notification.show();
  }
}

// globals
const analytics = new AmplitudeAnalyticsClient();
const autoUpdater = new F2aAutoUpdater(logger, quit, analytics);
const supabase = createClient<DbSchema>(ENV.supabase.url, ENV.supabase.key);
const supabaseApi = new F2aSupabaseApi(supabase);
const htmlDownloaders = [
  new HtmlDownloader({
    numInstances: 2,
    incognitoMode: false,
  }),
  new HtmlDownloader({
    numInstances: 1,
    incognitoMode: true,
  }),
];
let jobScanner: JobScanner | undefined;
let trayMenu: TrayMenu | undefined;
const jobBoardModal = new JobBoardModal();

function navigate({ path }: { path: string }) {
  logger.info(LogSection.MAIN, `Sending nav event to ${path}`);
  mainWindow?.webContents.send('navigate', { path });
  onActivate(); // make sure the window is visible
}

async function handleDeepLink(url: string) {
  try {
    if (!url.startsWith(APP_PROTOCOL)) return;

    onActivate();
    const path = url.replace(`${APP_PROTOCOL}:/`, '');

    // handle password reset links, parse hash and extract supabase tokens
    if (path.startsWith('/reset-password')) {
      const hash = path.replace(/\/reset-password\/?#/i, '');
      const params = new URLSearchParams(hash);
      const allHashParams = Object.fromEntries(params.entries());

      // @ts-ignore
      const { error } = await supabase.auth.setSession(allHashParams);
      if (error) throw error;
    }

    navigate({ path });
  } catch (error) {
    logger.error(LogSection.MAIN, getExceptionMessage(error));
    dialog.showErrorBox('Error', getExceptionMessage(error, true));
  }
}

/**
 * Bootstrap probe service.
 */
async function bootstrap() {
  try {
    // do not allow multiple instances on Windows
    const gotTheLock = app.requestSingleInstanceLock();
    if (!gotTheLock) {
      app.quit();
      return;
    }

    if (!ENV.appBundleId) throw new Error(`missing APP_BUNDLE_ID`);
    if (process.platform === 'win32') {
      app.setAppUserModelId(ENV.appBundleId);
    }

    // track the app start event
    analytics.trackEvent('app_start');

    // start auto-updater
    autoUpdater.start();

    // init the HTML downloader
    htmlDownloaders.forEach((htmlDownloader) => htmlDownloader.init());
    const [normalHtmlDownloader, incognitoHtmlDownloader] = htmlDownloaders;

    // init the job scanner
    jobScanner = new JobScanner({
      supabaseApi,
      normalHtmlDownloader,
      incognitoHtmlDownloader,
      onNavigate: navigate,
      analytics,
    });

    // init the renderer IPC API
    console.log('ðŸ”§ About to initialize renderer IPC API...');
    initRendererIpcApi({ supabaseApi, jobScanner, autoUpdater, jobBoardModal, nodeEnv: ENV.nodeEnv });
    console.log('ðŸ”§ Renderer IPC API initialized successfully');

    // init the tray menu
    trayMenu = new TrayMenu({ logger, onQuit: quit, onNavigate: navigate });

    const userDataPath = app.getPath('userData');
    const sessionPath = path.join(userDataPath, `${ENV.nodeEnv}-encrypted-session.json`);

    // manual logout for testing
    // fs.unlinkSync(sessionPath);

    // save the session to disk when it changes
    supabase.auth.onAuthStateChange(async (event, session) => {
      try {
        logger.info(LogSection.AUTH, `Auth state change: ${event}`, { userId: session?.user?.id || 'none' });

        if (session?.user?.id) {
          // set the user id for logging and analytics
          analytics.setUserId(session.user.id);
        }

        // clear the session from disk if it's being removed
        if (event === 'SIGNED_OUT') {
          logger.info(LogSection.AUTH, `Removing session from disk`);
          fs.unlinkSync(sessionPath);
        } else if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || event === 'PASSWORD_RECOVERY') {
          logger.info(LogSection.AUTH, `Saving new session to disk`);
          if (safeStorage.isEncryptionAvailable()) {
            const encryptedSession = safeStorage.encryptString(JSON.stringify(session));
            fs.writeFileSync(sessionPath, encryptedSession.toString('base64'), 'utf-8');
          } else {
            logger.error(LogSection.AUTH, `Encryption is not available, cannot save plain session to disk`);
          }
        }
      } catch (error) {
        logger.error(LogSection.AUTH, getExceptionMessage(error));
      }
    });

    // load the session from disk if it exists
    if (fs.existsSync(sessionPath)) {
      const encryptedSession = fs.readFileSync(sessionPath, 'utf-8');
      const plaintextSession = safeStorage.decryptString(Buffer.from(encryptedSession, 'base64'));
      const session = JSON.parse(plaintextSession);
      logger.info(LogSection.AUTH, `Finished loading session from disk`);

      // If the saved session belongs to a different Supabase project, drop it
      try {
        const currentHost = new URL(ENV.supabase.url || '').host;
        const accessToken: string | undefined = session?.access_token;
        const tokenIss: string | undefined = (() => {
          if (!accessToken || typeof accessToken !== 'string' || !accessToken.includes('.')) return undefined;
          try {
            const payload = JSON.parse(Buffer.from(accessToken.split('.')[1], 'base64').toString('utf-8'));
            return typeof payload?.iss === 'string' ? payload.iss : undefined;
          } catch {
            return undefined;
          }
        })();

        console.log('ðŸ”§ [session] Session validation:', {
          currentHost,
          tokenIss,
          hasAccessToken: !!accessToken,
          tokenExpiry: accessToken ? (() => {
            try {
              const payload = JSON.parse(Buffer.from(accessToken.split('.')[1], 'base64').toString('utf-8'));
              return new Date(payload.exp * 1000).toISOString();
            } catch { return 'invalid'; }
          })() : 'none'
        });

        if (!currentHost || !tokenIss || !tokenIss.includes(currentHost)) {
          logger.info(LogSection.AUTH, 'Saved session does not match current Supabase project, clearing saved session');
          fs.unlinkSync(sessionPath);
        } else {
          console.log('ðŸ”§ [session] Setting session from disk...');
          const { error } = await supabase.auth.setSession(session);
          if (error) {
            console.log('ðŸ”§ [session] Error setting session:', error.message);
            throw error;
          }
          console.log('ðŸ”§ [session] Session set successfully');

          // perform an initial scan
          jobScanner.scanAllLinks().catch((error) => {
            logger.error(LogSection.AUTH, getExceptionMessage(error));
          });
        }
      } catch (e) {
        console.log('ðŸ”§ [session] Error in session handling:', getExceptionMessage(e));
        logger.error(LogSection.AUTH, getExceptionMessage(e));
        try { fs.unlinkSync(sessionPath); } catch {}
      }
    } else {
      logger.info(LogSection.AUTH, `No session found on disk`);
    }
  } catch (error) {
    logger.error(LogSection.AUTH, getExceptionMessage(error));
  }

  // create the main window after everything is setup
  const mainWindow = createMainWindow();
  jobBoardModal.setMainWindow(mainWindow);
  
  // Make sure the window is visible
  if (mainWindow) {
    mainWindow.show();
    mainWindow.focus();
    if (process.platform === 'darwin') {
      app.dock.show();
    }
  }

  // handle deep links on macOS and linux
  app.on('open-url', (event, url) => {
    event.preventDefault();
    handleDeepLink(url);
  });

  // handle deep links on Windows
  app.on('second-instance', (event, commandLine) => {
    handleDeepLink(commandLine[commandLine.length - 1]);
  });

  appIsRunning = true;
}

/**
 * Method used to quit the app.
 */
async function quit() {
  try {
    logger.info(LogSection.MAIN, `Quitting...`);
    appIsRunning = false;

    jobScanner?.close();
    logger.info(LogSection.MAIN, `Closed job scanner`);

    await promiseAllSequence(htmlDownloaders, (htmlDownloader) => htmlDownloader.close());
    logger.info(LogSection.MAIN, `Closed HTML downloader`);

    trayMenu?.close();
    logger.info(LogSection.MAIN, `Closed tray menu`);

    autoUpdater.stop();
    logger.info(LogSection.MAIN, `Stopped auto updater`);

    storage.set('width', mainWindow?.getSize()[0] || 1024);
    storage.set('height', mainWindow?.getSize()[1] || 800);

    mainWindow?.removeAllListeners();
    logger.info(LogSection.MAIN, `Removed all main window listeners`);

    mainWindow?.close();
    logger.info(LogSection.MAIN, `Closed main window`);

    analytics.trackEvent('app_quit');

    analytics.flush();
  } catch (error) {
    logger.error(LogSection.MAIN, getExceptionMessage(error));
    process.exit(-1); // force quit
  }
}
